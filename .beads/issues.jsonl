{"id":"speak-0vs","title":"Add per-event-type sound effects","description":"From cc-hooks by husniadil. Different Claude Code hook events get distinct audio cues: a chime for task completion, a click for tool use, a warning tone for errors, etc. cc-hooks maps specific hook events (PreToolUse, PostToolUse, UserPromptSubmit, Stop, Notification) to bundled sound effect files. This helps the user understand what's happening without needing to listen to full text. Could be implemented as pre-recorded PCM samples injected into the audio stream before spoken text.","status":"open","priority":3,"issue_type":"task","owner":"trillium@trilliumsmith.com","created_at":"2026-02-21T00:27:10Z","created_by":"Trillium Smith","updated_at":"2026-02-21T00:27:10Z","labels":["enhancement","research-finding"]}
{"id":"speak-1xv","title":"Use NLTK/Stanza sentence tokenization instead of regex","description":"From RealtimeTTS by KoljaB. Our current clause splitting uses regex on punctuation marks (.\\!?,;:--). RealtimeTTS uses NLTK or Stanza sentence tokenizers which handle edge cases much better: abbreviations (Dr., U.S.A.), decimal numbers (3.14), URLs, quoted speech, and other tricky patterns. NLTK's punkt tokenizer is lightweight and well-tested. This would improve clause boundary detection without adding heavy dependencies.","status":"open","priority":3,"issue_type":"task","owner":"trillium@trilliumsmith.com","created_at":"2026-02-21T00:26:58Z","created_by":"Trillium Smith","updated_at":"2026-02-21T00:26:58Z","labels":["enhancement","research-finding"]}
{"id":"speak-2w6","title":"Add voice formula blending support","description":"From RealtimeTTS's KokoroEngine. Kokoro supports blending multiple voice profiles using weighted formulas like '0.3*af_sarah + 0.7*am_adam'. This creates unique voice textures without needing additional voice models. RealtimeTTS implements this by loading multiple voice tensors and combining them with the specified weights. Could expose this via --voice '0.5*af_heart+0.5*am_adam' syntax.","status":"open","priority":4,"issue_type":"task","owner":"trillium@trilliumsmith.com","created_at":"2026-02-21T00:27:04Z","created_by":"Trillium Smith","updated_at":"2026-02-21T00:27:04Z","labels":["enhancement","research-finding"]}
{"id":"speak-5cb","title":"Add SQLite event persistence with retry logic","description":"From cc-hooks by husniadil. Currently our playback queue is in-memory only - if the daemon crashes, pending items are lost. cc-hooks uses SQLite with a proper state machine (PENDING -\u003e PROCESSING -\u003e COMPLETED/FAILED), atomic claim-based processing, configurable max retries, and delay between attempts. Also enables event history for debugging and replay. Consider storing queue items in SQLite for durability across daemon restarts.","status":"open","priority":2,"issue_type":"task","owner":"trillium@trilliumsmith.com","created_at":"2026-02-21T00:26:51Z","created_by":"Trillium Smith","updated_at":"2026-02-21T00:26:51Z","labels":["enhancement","reliability","research-finding"]}
{"id":"speak-69m","title":"Add COMPLETED convention for brief agent summaries","description":"From Benny Cheung's AgentVoices project. Agents append standardized ~12-word past-tense summaries (e.g. 'COMPLETED: Refactored authentication module and added unit tests'). Claude Code hooks parse these lines via regex and speak only the brief summary, not the full output. This constrains what gets spoken to naturally-phrased outcomes. Could be implemented as a hook that detects COMPLETED lines and pipes them to speak --enqueue.","notes":"Partially addressed: the hook pipeline now summarizes Claude output via Haiku before speaking, which achieves a similar result. The formal COMPLETED convention (agents explicitly outputting structured summaries) remains a future enhancement.","status":"open","priority":3,"issue_type":"task","owner":"trillium@trilliumsmith.com","created_at":"2026-02-21T00:26:45Z","created_by":"Trillium Smith","updated_at":"2026-02-21T01:20:14Z","labels":["enhancement","research-finding"]}
{"id":"speak-auf","title":"Investigate ffplay stale audio issue","description":"ffplay occasionally goes silent - process stays alive and accepts stdin data but stops outputting audio. write=0ms on all items indicates no backpressure. Research agent found that SDL2 CoreAudio has device migration (SDL2 2.32+) but ffplay has zero SDL_AUDIODEVICEREMOVED handling and no fallback logic. Current workaround: recycle ffplay between queue batches. Need a proper health check or ffplay recycling strategy. Possible approaches: (1) monitor write backpressure and recycle if consistently 0ms, (2) periodic ffplay restart between batches, (3) switch to a different audio backend.","notes":"Current workaround: daemon recycles ffplay between queue batches. Research found SDL2 CoreAudio has no reconnection logic in ffplay. Still needs a proper health check (monitor write backpressure, recycle if consistently 0ms).","status":"open","priority":1,"issue_type":"task","owner":"trillium@trilliumsmith.com","created_at":"2026-02-21T00:27:25Z","created_by":"Trillium Smith","updated_at":"2026-02-21T01:20:09Z","labels":["bug","reliability","research-finding"]}
{"id":"speak-enf","title":"Add Claude Code hook integration","description":"Multiple competing projects (clarvis, cc-hooks, multi-agent-observability, Benny Cheung) integrate with Claude Code via hooks. We should add hook scripts that capture Claude Code lifecycle events (especially Stop/Notification) and pipe relevant text to speak --enqueue. This is the primary way agents would automatically speak without manual speak --enqueue calls. The auto-detect caller feature already identifies the git repo, so hooks would automatically get proper caller identification.","notes":"Implemented in .claude/hooks/speak-hook.sh. Hooks configured in ~/.claude/settings.json for Stop, Notification, and SubagentStop events. All async. Uses bin/summarize (Haiku) + bin/speak-summarize (pronunciation/phrase rewrites) pipeline.","status":"closed","priority":2,"issue_type":"task","owner":"trillium@trilliumsmith.com","created_at":"2026-02-21T00:27:17Z","created_by":"Trillium Smith","updated_at":"2026-02-21T01:19:44Z","closed_at":"2026-02-21T01:19:44Z","labels":["enhancement","integration","research-finding"]}
{"id":"speak-fjr","title":"Add pronunciation dictionary and phrase rewrite system","description":"Implemented config/rewrites.json with two sections: pronunciation fixes and phrase rewrites. Applied by bin/speak-summarize.","status":"closed","priority":2,"issue_type":"task","owner":"trillium@trilliumsmith.com","created_at":"2026-02-21T01:19:58Z","created_by":"Trillium Smith","updated_at":"2026-02-21T01:20:03Z","closed_at":"2026-02-21T01:20:03Z","close_reason":"Closed","labels":["enhancement"]}
{"id":"speak-jr7","title":"Add LLM summarization of verbose output before speaking","description":"Agent-tts and clarvis both use Claude Haiku or similar LLMs to condense verbose agent output into 1-3 sentence spoken summaries. This makes audio notifications actually useful rather than reading raw verbose text. Could be a thin wrapper that calls an LLM and pipes result to speak --enqueue. Inspired by: agent-tts (message-processor.ts haiku() function) and clarvis (Jarvis-style summarization modes: terse/brief/normal/full).","notes":"Implemented as bin/summarize standalone tool. Uses claude -p with Haiku. Short text passes through unchanged. Swappable backend by editing one file. Wired into hook pipeline: summarize → speak-summarize → speak --enqueue.","status":"closed","priority":3,"issue_type":"task","owner":"trillium@trilliumsmith.com","created_at":"2026-02-21T00:26:38Z","created_by":"Trillium Smith","updated_at":"2026-02-21T01:19:50Z","closed_at":"2026-02-21T01:19:50Z","labels":["enhancement","research-finding"]}
{"id":"speak-kv3","title":"Fast enqueue client: C binary or Perl for hot path","description":"Research complete. Current Python speak-client adds ~16ms startup per enqueue call. Three options benchmarked: (1) C binary speak-enqueue at 3.5ms, (2) Perl one-liner at 9ms using system perl, (3) printf+nc at 4.3ms fire-and-forget. Recommendation: compile C binary for enqueue hot path, keep Python client for streaming/interactive. See task a3b8c95 output for full code examples.","status":"open","priority":3,"issue_type":"task","owner":"trillium@trilliumsmith.com","created_at":"2026-02-21T01:34:55Z","created_by":"Trillium Smith","updated_at":"2026-02-21T01:34:55Z","labels":["enhancement","performance"]}
{"id":"speak-poq","title":"Auto-suggest phonetic rewrites for unknown words","description":"When speak encounters a word without a pronunciation rewrite, auto-generate a candidate using eng-to-ipa (CMU dict) with espeak-ng fallback. Would need an IPA-to-phonetic-spelling translation layer since Kokoro takes plain text, not IPA. Queue candidates into rewrites-review.json as pending for user review. See also g2p-en for neural fallback on novel words.","status":"open","priority":4,"issue_type":"task","owner":"trillium@trilliumsmith.com","created_at":"2026-02-21T02:35:52Z","created_by":"Trillium Smith","updated_at":"2026-02-21T02:35:52Z","labels":["enhancement","rewrites"]}
