#!/usr/bin/env python3
"""Stream Kokoro TTS audio as raw PCM to stdout, one sentence at a time."""

import asyncio
import re
import sys
import numpy as np
from kokoro_onnx import Kokoro

# Fix kokoro-onnx bug: speed dtype is np.int32 instead of np.float32
# for models using input_ids format (v1.0 models)
_orig_create_audio = Kokoro._create_audio
def _fixed_create_audio(self, phonemes, voice, speed):
    orig_run = self.sess.run
    def patched_run(output_names, inputs, *args, **kwargs):
        if "speed" in inputs and hasattr(inputs["speed"], "dtype"):
            inputs["speed"] = np.array(inputs["speed"], dtype=np.float32)
        return orig_run(output_names, inputs, *args, **kwargs)
    self.sess.run = patched_run
    try:
        return _orig_create_audio(self, phonemes, voice, speed)
    finally:
        self.sess.run = orig_run
Kokoro._create_audio = _fixed_create_audio

_CLAUSE_RE = re.compile(r'(?<=[.!?,;:\u2014â€”-])\s+')

async def main():
    import argparse
    parser = argparse.ArgumentParser()
    parser.add_argument("--model", required=True)
    parser.add_argument("--voices", required=True)
    parser.add_argument("--voice", default="af_heart")
    parser.add_argument("--speed", type=float, default=1.0)
    parser.add_argument("--lang", default="en-us")
    args = parser.parse_args()

    text = sys.stdin.read().strip()
    if not text:
        return

    kokoro = Kokoro(args.model, args.voices)
    voice = kokoro.get_voice_style(args.voice)
    loop = asyncio.get_event_loop()

    clauses = [s.strip() for s in _CLAUSE_RE.split(text) if s.strip()]

    for sentence in clauses:
        phonemes = kokoro.tokenizer.phonemize(sentence, args.lang)
        audio, sample_rate = await loop.run_in_executor(
            None, kokoro._create_audio, phonemes, voice, args.speed
        )
        pcm = (audio * 32767).astype(np.int16)
        sys.stdout.buffer.write(pcm.tobytes())
        sys.stdout.buffer.flush()

asyncio.run(main())
