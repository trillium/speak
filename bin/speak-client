#!/usr/bin/env python3
"""Connect to speak-daemon, send text, stream raw PCM to stdout."""

import json
import os
import socket
import struct
import sys


def _send_request(sock, request_dict):
    """Send a length-prefixed JSON request."""
    payload = json.dumps(request_dict).encode()
    sock.sendall(struct.pack("!I", len(payload)))
    sock.sendall(payload)


def _read_json_response(sock):
    """Read a length-prefixed JSON response (first chunk), consuming the zero terminator."""
    raw_len = _recvall(sock, 4)
    if not raw_len:
        return None
    chunk_len = struct.unpack("!I", raw_len)[0]
    if chunk_len == 0:
        return None
    data = _recvall(sock, chunk_len)
    if not data:
        return None
    # Consume the zero-length terminator
    term = _recvall(sock, 4)
    if term:
        struct.unpack("!I", term)  # should be 0
    return json.loads(data.decode())


def main():
    import argparse
    parser = argparse.ArgumentParser()
    parser.add_argument("--voice", default="af_heart")
    parser.add_argument("--speed", type=float, default=1.0)
    parser.add_argument("--lang", default="en-us")
    parser.add_argument("--enqueue", action="store_true",
                        help="Enqueue text for playback and return immediately")
    parser.add_argument("--caller", default="",
                        help="Caller identity for distinct audio tones")
    parser.add_argument("--session", default=str(os.getppid()),
                        help="Session ID for voice pool (default: PPID)")
    parser.add_argument("--command",
                        help="Send a queue command (queue_status, skip, clear, replay)")
    parser.add_argument("--subscribe", action="store_true",
                        help="Subscribe to audio broadcast (PCM to stdout, metadata to stderr)")
    args = parser.parse_args()

    sock_path = f"/tmp/speak-{os.environ['USER']}.sock"
    sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
    sock.connect(sock_path)

    # --- Command mode (no text needed) ---
    if args.command:
        _send_request(sock, {"command": args.command})
        resp = _read_json_response(sock)
        sock.close()
        if resp:
            print(json.dumps(resp, indent=2))
        return

    # --- Subscribe mode ---
    if args.subscribe:
        _send_request(sock, {"command": "subscribe", "include_metadata": True})
        resp = _read_json_response(sock)
        if resp:
            print(json.dumps(resp), file=sys.stderr)
        # Read broadcast frames: [4-byte len][1-byte type][payload]
        try:
            while True:
                raw_len = _recvall(sock, 4)
                if not raw_len:
                    break
                frame_len = struct.unpack("!I", raw_len)[0]
                if frame_len == 0:
                    print("subscribe: daemon shutdown", file=sys.stderr)
                    break
                frame = _recvall(sock, frame_len)
                if not frame:
                    break
                frame_type = frame[0]
                payload = frame[1:]
                if frame_type == 0x01:  # audio
                    sys.stdout.buffer.write(payload)
                    sys.stdout.buffer.flush()
                elif frame_type == 0x02:  # metadata
                    print(payload.decode(), file=sys.stderr)
        except KeyboardInterrupt:
            pass
        finally:
            sock.close()
        return

    text = sys.stdin.read().strip()
    if not text:
        sock.close()
        return

    # --- Enqueue mode ---
    if args.enqueue:
        req = {
            "enqueue": True,
            "text": text,
            "voice": args.voice,
            "speed": args.speed,
            "lang": args.lang,
            "session": args.session,
        }
        if args.caller:
            req["caller"] = args.caller
        _send_request(sock, req)
        resp = _read_json_response(sock)
        sock.close()
        if resp and resp.get("ok"):
            print(f"queued (position {resp['position']})", file=sys.stderr)
        elif resp:
            print(f"speak-client: enqueue failed: {resp}", file=sys.stderr)
            sys.exit(1)
        return

    # --- Original streaming mode ---
    _send_request(sock, {
        "text": text,
        "voice": args.voice,
        "speed": args.speed,
        "lang": args.lang,
    })

    # Read length-prefixed PCM chunks and write to stdout
    while True:
        raw_len = _recvall(sock, 4)
        if not raw_len:
            break
        chunk_len = struct.unpack("!I", raw_len)[0]
        if chunk_len == 0:
            break
        pcm = _recvall(sock, chunk_len)
        if not pcm:
            break
        sys.stdout.buffer.write(pcm)
        sys.stdout.buffer.flush()

    sock.close()


def _recvall(sock, n):
    data = b""
    while len(data) < n:
        chunk = sock.recv(n - len(data))
        if not chunk:
            return None
        data += chunk
    return data


if __name__ == "__main__":
    main()
